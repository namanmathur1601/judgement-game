<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Judgement Game Scoring</title>

<style>
  :root {
    --primary: #287582;
    --primary-hover: #0062d1;
    --secondary: #28a745;
    --secondary-hover: #208d3a;
    --danger: #dc3545;
    --danger-hover: #b12a36;
    --accent-bg: #f8faff;
    --text-dark: #2c3e50;
    --card-bg: #BDDBC4;
  }

  body {
    font-family: "Segoe UI", Tahoma, sans-serif;
    margin: 0;
    background: #8C3A3A;
    color: var(--text-dark);
  }

  .container {
    max-width: 1100px;
    margin: 25px auto;
    background: var(--card-bg);
    padding: 25px 30px;
    border-radius: 14px;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08);
    transition: box-shadow 0.3s ease;
  }
  .container:hover {
    box-shadow: 0 10px 26px rgba(0, 0, 0, 0.12);
  }

  h2, h3 {
    text-align: center;
    margin-bottom: 20px;
    color: var(--text-dark);
    letter-spacing: 0.4px;
  }

/* üé¥ Decorative card icons around title */
.title-with-cards {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 20px;
  margin-bottom: 10px;
  flex-wrap: wrap;
  position: relative;
}

.cards-row {
  display: flex;
  gap: 6px;
}

.card-suit {
  font-size: 32px;
  background: white;
  border-radius: 6px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  padding: 6px 10px;
  transform: rotate(var(--angle, 0deg));
  animation: floatCard 3s ease-in-out infinite;
}

.card-suit.red { color: #d32f2f; }
.card-suit:not(.red) { color: #222; }

.cards-row.left .card-suit:nth-child(1) { --angle: -15deg; }
.cards-row.left .card-suit:nth-child(2) { --angle: 5deg; }
.cards-row.left .card-suit:nth-child(3) { --angle: -8deg; }

.cards-row.right .card-suit:nth-child(1) { --angle: 10deg; }
.cards-row.right .card-suit:nth-child(2) { --angle: -5deg; }
.cards-row.right .card-suit:nth-child(3) { --angle: 12deg; }

@keyframes floatCard {
  0%,100% { transform: rotate(var(--angle)) translateY(0); }
  50% { transform: rotate(var(--angle)) translateY(-4px); }
}

  input, button, select {
    padding: 9px 12px;
    margin: 5px;
    border-radius: 8px;
    border: 1px solid #ccc;
    font-size: 14px;
    transition: all 0.2s ease-in-out;
  }

  input:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.4);
  }

  button {
    background: var(--primary);
	box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    color: #fff;
    border: none;
    cursor: pointer;
    font-weight: 500;
    letter-spacing: 0.3px;
  }
  button:hover {
    background: var(--primary-hover);
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    transform: translateY(-1px);
  }

  .btn-secondary {
    background: var(--secondary);
	box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }
  .btn-secondary:hover {
    background: var(--secondary-hover);
	box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }

  .btn-danger {
    background: var(--danger);
	box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }
  .btn-danger:hover {
    background: var(--danger-hover);
	box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }

  .btn-pdf {
    background: #6f42c1;
	box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }
  .btn-pdf:hover {
    background: #5830a5;
	box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
    font-size: 14px;
    border-radius: 8px;
    overflow: hidden;
  }

  th, td {
    border: 1px solid #ddd;
    padding: 10px;
    text-align: center;
  }

  th {
    background: var(--primary);
    color: white;
    font-weight: 600;
  }

  tr:nth-child(even) {
    background: #f9f9f9;
  }

  table tr:hover {
    background-color: #eef6ff;
    transition: background 0.2s ease;
  }

  .score-positive {
    color: #218838;
    font-weight: 600;
  }

  .score-negative {
    color: #d63031;
    font-weight: 600;
  }

  .leader {
    background: #fff3cd !important;
  }

  .loser {
    background: #f8d7da !important;
  }

  .progress-bar-container {
    width: 100%;
    background: #e8edf3;
    border-radius: 6px;
    margin: 10px 0;
    height: 18px;
  }

  .progress-bar {
    height: 18px;
    background: var(--primary);
    border-radius: 6px;
    width: 0%;
    transition: width 0.4s ease-in-out, background 0.3s;
  }

  #roundColor {
    margin-left: 12px;
    font-size: 35px;
    font-weight: bold;
	filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));
    vertical-align: middle;
  }

  #roundNum {
    background: var(--primary);
    color: #fff;
    padding: 4px 10px;
    border-radius: 6px;
  }

  #gameOver {
    text-align: center;
    font-size: 20px;
    font-weight: bold;
    color: var(--secondary);
    margin-top: 20px;
  }

  .round-card {
    background: var(--card-bg);
    margin: 14px 0;
    padding: 12px 14px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }
  .round-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .round-card h4 {
    margin: 0 0 10px 0;
    padding: 8px 10px;
    border-radius: 6px;
    color: #fff;
    font-size: 15px;
  }

.active-row {
  background-color: #3CB371 !important; /* soft but deeper green */
  box-shadow: inset 0 0 6px rgba(0, 100, 0, 0.25);
  transition: background 0.25s ease, box-shadow 0.25s ease;
}

  #overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 998;
  }

  .modal {
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #fff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
    z-index: 999;
    width: 400px;
    max-width: 90%;
  }

  .modal h3 {
    margin-top: 0;
    text-align: center;
    font-weight: 600;
  }

  /* Mobile Responsive Tweaks */
  @media (max-width: 768px) {
    .container {
      padding: 15px;
    }

    table, th, td {
      font-size: 12px;
    }

    button {
      width: 100%;
      margin-top: 6px;
    }

    h2 {
      font-size: 20px;
    }

    .modal {
      width: 90%;
    }
  }
  
  /* --- Winner Card Styling --- */
#winnerCard {
  display: none;
  text-align: center;
  background: linear-gradient(135deg, #28a745, #007bff);
  color: white;
  padding: 25px;
  border-radius: 12px;
  margin-top: 25px;
  font-size: 22px;
  font-weight: 600;
  box-shadow: 0 6px 18px rgba(0,0,0,0.2);
  animation: fadeInUp 0.8s ease;
}

#winnerCard span {
  display: block;
  font-size: 18px;
  font-weight: normal;
  opacity: 0.9;
  margin-top: 6px;
}

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Optional confetti background effect */
.confetti {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
  z-index: 1000;
}

#backgroundCards {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  overflow: hidden;
  pointer-events: none;
  opacity: 0.3; /* Increased visibility */
}

.bg-card-group {
  position: absolute;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  transform: rotate(var(--angle, 0deg));
  animation: floatCards 10s ease-in-out infinite;
}

.bg-card {
  font-size: 58px;
  background: white;
  border-radius: 10px;
  padding: 8px 10px;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.25);
  opacity: 1; /* fully visible */
  transform: scale(1.05);
}


.bg-card.red { color: #d32f2f; }
.bg-card.black { color: #111; }

@keyframes floatCards {
  0%, 100% { transform: rotate(var(--angle)) translateY(0); }
  50% { transform: rotate(var(--angle)) translateY(-20px); }
}



/* ---- Landing Screen Enhancement ---- */
#setup {
  text-align: center;
  padding: 40px 20px;
  /*background: linear-gradient(135deg, #DC143C, #ffe8d6);*/
  border-radius: 16px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  transition: all 0.3s ease-in-out;
}

#setup:hover {
  box-shadow: 0 6px 25px rgba(0,0,0,0.15);
}

#setup h3 {
  font-size: 22px;
  margin-bottom: 20px;
  color: #1e3a8a;
  font-weight: 600;
  letter-spacing: 0.5px;
}

#playerName {
  width: 260px;
  font-size: 15px;
  border: 1.5px solid #007bff;
  border-radius: 10px;
  transition: all 0.2s ease;
}

#playerName:focus {
  border-color: #00bcd4;
  box-shadow: 0 0 6px rgba(0,188,212,0.3);
}

#setup button {
  border-radius: 8px;
  padding: 10px 18px;
  font-size: 15px;
  font-weight: 500;
  margin: 8px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  transition: all 0.25s ease;
}

#setup button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

#maxCardsInput {
  width: 120px;
  text-align: center;
  border-radius: 8px;
  border: 1.5px solid #007bff;
  font-size: 15px;
  transition: all 0.25s ease;
}

#maxCardsInput:focus {
  border-color: #00bcd4;
  box-shadow: 0 0 6px rgba(0,188,212,0.3);
}

.actions {
  margin-top: 20px;
}

/* Optional: soft background animation for a living feel */
@keyframes subtlePulse {
  0% { background: linear-gradient(135deg, #D2691E, #d4f9f0); }
  50% { background: linear-gradient(135deg, #D2691E, #ccf6ef); }
  100% { background: linear-gradient(135deg, #D2691E, #d4f9f0); }
}

#setup {
  animation: subtlePulse 8s ease-in-out infinite;
}
/* --- Player List Styling --- */
#playerList {
  list-style-type: none; /* removes bullets */
  padding: 0;
  margin: 15px auto;
  text-align: center;
}

#playerList li {
  display: inline-block;
  background: #007bff10;
  border: 1.5px solid #007bff33;
  color: #003366;
  font-weight: 600;
  font-size: 16px;
  margin: 6px;
  padding: 8px 14px;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.08);
  transition: all 0.25s ease;
}

#playerList li:hover {
  background: #007bff20;
  transform: translateY(-2px);
  box-shadow: 0 3px 8px rgba(0,0,0,0.1);
}
/* --- Modern Button Design --- */
button {
  background: linear-gradient(135deg, #007bff, #3D596B);
  color: #fff;
  border: none;
  border-radius: 10px;
  padding: 10px 18px;
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.3px;
  cursor: pointer;
  transition: all 0.25s ease;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}
button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0,0,0,0.25);
  filter: brightness(1.1);
}

/* Variant Buttons */
.btn-secondary {
  background: linear-gradient(135deg, #28a745, #00c851);
}
.btn-danger {
  background: linear-gradient(135deg, #dc3545, #ff4b5c);
}
.btn-pdf {
  background: linear-gradient(135deg, #6f42c1, #8a63d2);
}

/* --- Table Styling Refresh --- */
table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  border-radius: 12px;
  overflow: hidden;
  background: #ffffff;
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}

th {
  background: linear-gradient(135deg, #007bff, #3D596B);
  color: white;
  text-transform: uppercase;
  font-size: 13px;
  letter-spacing: 0.5px;
  padding: 12px;
}

td {
  padding: 10px;
  font-size: 14px;
  border-bottom: 1px solid #e9ecef;
  transition: background 0.2s ease;
}

tr:hover td {
  background: #f5fcff;
}

/* --- Inputs Slight Upgrade --- */
input[type="number"], input[type="text"] {
  border: 1.5px solid #d0e6f6;
  border-radius: 8px;
  padding: 8px 10px;
  transition: all 0.25s ease;
}
input:focus {
  border-color: #00bcd4;
  box-shadow: 0 0 6px rgba(0,188,212,0.3);
}

/* --- Compact Container Version --- */
.container {
  max-width: 1100px;             /* reduce width */
  padding: 18px 20px;           /* tighter padding */
  transform: scale(0.90);       /* scale everything inside proportionally */
  transform-origin: top center; /* keeps layout centered */
}

.container:hover {
  transform: scale(0.90);       /* subtle hover zoom */
}



</style>

</head>
<body>
<div id="backgroundCards"></div>
<div class="container">
<div class="title-with-cards">
  <div class="cards-row left">
    <div class="card-suit">‚ô†</div>
    <div class="card-suit red">‚ô•</div>
    <div class="card-suit">‚ô£</div>
  </div>

  <h2>Judgement Game</h2>

  <div class="cards-row right">
    <div class="card-suit red">‚ô¶</div>
    <div class="card-suit">‚ô†</div>
    <div class="card-suit red">‚ô•</div>
  </div>
</div>

  <div id="setup">
    <h3>Start by setting up players</h3>
    <input type="text" id="playerName" placeholder="Player Name">
    <button onclick="addPlayer()">Add Player</button>
	<h5>OR</h5>
    <button class="btn-secondary" onclick="openSelectModal()">Select from Master List</button>
    <button class="btn-pdf" onclick="openMasterList()">Manage Master List</button>
    <ul id="playerList"></ul>
    <div>
      <label>Enter maximum cards for first round: </label>
      <input type="number" id="maxCardsInput" min="1">
	  <div id="sequenceTypeContainer" style="margin-top:10px; display:none;">
	<label><input type="radio" name="sequenceType" value="reverse" checked> Reverse</label>
	<label style="margin-left:15px;"><input type="radio" name="sequenceType" value="reverseForward"> Reverse & Forward</label>
	</div>
    </div>

    <div class="actions">
      <button onclick="startGame()">Start Game!</button>
    </div>
  </div>

  <div id="game" style="display:none;">
    <h3>Round <span id="roundNum">1</span> <span id="roundColor"></span></h3>
    <div><label>Cards this round: </label><input type="number" id="cardsThisRound" readonly></div>
    <div class="progress-bar-container"><div class="progress-bar" id="progressBar"></div></div>
    <div id="roundInputs"></div>
    <button onclick="submitPredictions()" class="btn-secondary">Lock Predictions</button>
    <span id="predSumDisplay" style="margin-left:10px;font-weight:600;"></span>

    <div style="text-align:center;margin-top:15px;">
      <button onclick="submitRound()" id="submitBtn">Submit and proceed to next round</button>
      <button class="btn-danger" onclick="undoLastRound()">Undo Last Round</button>
      <button class="btn-danger" onclick="confirmNewGame()">Start New Game</button>
	  <button class="btn-secondary" onclick="exportHistory()">Export CSV</button>
      <button class="btn-pdf" onclick="exportPDF()">Export PDF</button>
    </div>



    <h3>üèÜ Scoreboard</h3>
    <table id="scoreTable">
      <thead><tr><th>Rank</th><th>Player</th><th>Total Score</th></tr></thead>
      <tbody></tbody>
    </table>
	
	<div id="gameResultContainer">
  <div id="gameOver"></div>
  <div id="winnerCard"></div>
</div>

	    <div style="text-align:center;margin-top:10px;">
	      <button onclick="toggleHistory()">Show/Hide History</button>
      <label style="margin-right:8px;">Filter by Player:</label>
      <select id="playerFilter" onchange="renderHistory(this.value)" style="margin-right:10px;">
        <option value="All">All</option>
      </select>

	  
	      <div id="historySection"></div>


    </div>

	<div id="winnerCard"></div>
	<div class="confetti" id="confettiContainer"></div>
  </div>
</div>

<div id="overlay" onclick="closeAllModals()"></div>

<div id="masterModal" class="modal">
  <h3>Manage Master Player List</h3>
  <ul id="masterList"></ul>
  <input type="text" id="newMasterName" placeholder="Add new player">
  <button class="btn-secondary" onclick="addToMasterList()">Add</button>
  <button class="btn-danger" onclick="closeAllModals()">Close</button>
</div>

<div id="selectModal" class="modal">
  <h3>Select Players from Master List</h3>
  <div id="selectList"></div>
  <button class="btn-secondary" onclick="confirmPlayerSelection()">Confirm Selection</button>
  <button class="btn-danger" onclick="closeAllModals()">Cancel</button>
</div>

<script>
let players=[], scores={}, round=1, history=[], currentCards=0, maxCards=0;
let masterPlayers = JSON.parse(localStorage.getItem("judgementMasterPlayers")) || [];
let selectedPlayersOrder = [];
let sequenceType = "reverse";
let sequenceList = [];
let sequenceIndex = 0;


function getPlayerOrderForRound() {
  if (!players || players.length === 0) return [];
  const shift = (round - 1) % players.length;
  return [...players.slice(shift), ...players.slice(0, shift)];
}

// ---------- MASTER LIST ----------
function updateMasterStorage(){ localStorage.setItem("judgementMasterPlayers", JSON.stringify(masterPlayers)); }
function renderMasterList(){
  const ul=document.getElementById("masterList"); ul.innerHTML="";
  masterPlayers.forEach((p,i)=>{
    const li=document.createElement("li");
    li.textContent=p+" ";
    const del=document.createElement("button");
    del.textContent="‚ùå"; del.style.marginLeft="10px";
    del.onclick=()=>{ masterPlayers.splice(i,1); updateMasterStorage(); renderMasterList(); };
    li.appendChild(del);
    ul.appendChild(li);
  });
}
function openMasterList(){ renderMasterList(); document.getElementById("overlay").style.display="block"; document.getElementById("masterModal").style.display="block"; }
function openSelectModal(){
  if(masterPlayers.length===0){ alert("No master players yet. Please add some first."); return; }
  const selectDiv=document.getElementById("selectList");
  selectDiv.innerHTML=""; selectedPlayersOrder=[];
  masterPlayers.forEach(p=>{
    const label=document.createElement("label");
    label.style.display="block"; label.style.marginBottom="6px";
    const checkbox=document.createElement("input");
    checkbox.type="checkbox"; checkbox.value=p; checkbox.style.marginRight="8px";
    checkbox.addEventListener("change",function(){
      if(this.checked){ selectedPlayersOrder.push(p); }
      else{ selectedPlayersOrder=selectedPlayersOrder.filter(x=>x!==p); }
    });
    label.appendChild(checkbox); label.appendChild(document.createTextNode(p));
    selectDiv.appendChild(label);
  });
  document.getElementById("overlay").style.display="block";
  document.getElementById("selectModal").style.display="block";
}
function closeAllModals(){ document.getElementById("overlay").style.display="none"; document.querySelectorAll(".modal").forEach(m=>m.style.display="none"); }
function addToMasterList(){
  const name=document.getElementById("newMasterName").value.trim();
  if(name && !masterPlayers.includes(name)){ masterPlayers.push(name); updateMasterStorage(); renderMasterList(); document.getElementById("newMasterName").value=""; }
}
function confirmPlayerSelection(){
  if(selectedPlayersOrder.length===0){ alert("Select at least one player."); return; }
  players=[...selectedPlayersOrder];
  const list=document.getElementById("playerList"); list.innerHTML="";
  players.forEach(p=>{ const li=document.createElement("li"); li.textContent=p; list.appendChild(li); });
  closeAllModals();
}
function addPlayer(){
  const name=document.getElementById("playerName").value.trim();
  if(name && !players.includes(name)){
    players.push(name);
    if(!masterPlayers.includes(name)){ masterPlayers.push(name); updateMasterStorage(); }
    const li=document.createElement("li"); li.textContent=name;
    document.getElementById("playerList").appendChild(li);
    document.getElementById("playerName").value="";
  }
}

// ---------- GAME ----------
function updateRoundColor() {
  const suits = [
    { s: "‚ô†", c: "black" },
    { s: "‚ô•", c: "red" },
    { s: "‚ô¶", c: "red" },
    { s: "‚ô£", c: "black" }
  ];
  const cur = suits[(round - 1) % 4];

  // Update round color indicator
  const span = document.getElementById("roundColor");
  span.textContent = `(${cur.s})`;
  span.style.color = cur.c;

  // Render cards only along borders (left & right sides)
  const bgContainer = document.getElementById("backgroundCards");
  bgContainer.innerHTML = "";

  const totalGroups = 14; // more groups for fuller border effect
  for (let i = 0; i < totalGroups; i++) {
    const group = document.createElement("div");
    group.className = "bg-card-group";

    // Place groups only near left or right 10% of the screen
    const side = Math.random() < 0.5 ? "left" : "right";
    if (side === "left") {
      group.style.left = Math.random() * 8 + "vw"; // within left 0‚Äì8%
    } else {
      group.style.left = 92 + Math.random() * 8 + "vw"; // within right 92‚Äì100%
    }

    group.style.top = Math.random() * 90 + "vh";
    group.style.setProperty("--angle", `${Math.random() * 60 - 30}deg`);
    group.style.animationDelay = `${Math.random() * 4}s`;

    // Each group has 3‚Äì5 cards stacked randomly
    const count = 3 + Math.floor(Math.random() * 3);
    for (let j = 0; j < count; j++) {
      const card = document.createElement("div");
      card.className = `bg-card ${cur.c}`;
      card.textContent = cur.s;
      group.appendChild(card);
    }

    bgContainer.appendChild(group);
  }
}


function startGame() {
document.getElementById("sequenceTypeContainer").style.display = "none";

  if (players.length < 2) { alert("Add at least 2 players."); return; }

  maxCards = parseInt(document.getElementById("maxCardsInput").value);
  if (!maxCards || maxCards <= 0) { alert("Enter valid max cards."); return; }

  // Get selected sequence type
  sequenceType = document.querySelector('input[name="sequenceType"]:checked')?.value || "reverse";
  localStorage.setItem("sequenceType", sequenceType);
  localStorage.setItem("maxCards", maxCards);

  // Build sequence
  if (sequenceType === "reverseForward") {
    sequenceList = [...Array(maxCards).keys()].map(i => maxCards - i)
      .concat([...Array(maxCards).keys()].map(i => i + 1));
  } else {
    sequenceList = [...Array(maxCards).keys()].map(i => maxCards - i);
  }

  sequenceIndex = 0;
  currentCards = sequenceList[sequenceIndex];
  players.forEach(p => scores[p] = 0);

  document.getElementById("setup").style.display = "none";
  document.getElementById("game").style.display = "block";
  document.getElementById("roundNum").textContent = round;
  updateRoundColor();
  document.getElementById("cardsThisRound").value = currentCards;

  renderRoundInputs();
  renderScoreboard();
  updateProgress();
  populateFilter();
  saveGameState();
}


function highlightRow(p) {
  document.querySelectorAll("#roundInputs tr").forEach(tr=>tr.classList.remove("active-row"));
  const row = document.getElementById(`row-${p}`);
  if(row) row.classList.add("active-row");
}

function renderRoundInputs(){
  const order = getPlayerOrderForRound();
  const div=document.getElementById("roundInputs");
  div.innerHTML=`<table><thead><tr><th>Player</th><th>Prediction</th><th>Actual</th></tr></thead><tbody>${order.map(p=>`
    <tr id="row-${p}">
      <td style="font-weight:600;text-align:center;">${p}</td>
      <td><input type="number" min="0" id="pred-${p}" style="width:90%;padding:6px;"></td>
      <td><input type="number" min="0" id="act-${p}" style="width:90%;padding:6px;" disabled></td>
    </tr>`).join("")}</tbody></table>`;

  order.forEach(p=>{
    const pred=document.getElementById(`pred-${p}`);
    const act=document.getElementById(`act-${p}`);

    pred.addEventListener("focus",()=>highlightRow(p));
    act.addEventListener("focus",()=>highlightRow(p));

    pred.addEventListener("input",updatePredictionSum);
    pred.addEventListener("keydown",e=>{
      if(e.key==="Enter"||e.key==="Tab"){e.preventDefault();focusNextPrediction(p);}
    });
    act.addEventListener("keydown",e=>{
      if(e.key==="Enter"||e.key==="Tab"){e.preventDefault();focusNextActual(p);}
    });
  });

  // Auto focus on first prediction
  if(order.length>0){
    document.getElementById(`pred-${order[0]}`).focus();
    highlightRow(order[0]);
  }
}

function focusNextPrediction(currentPlayer){
  const order = getPlayerOrderForRound();
  const currentIndex = order.indexOf(currentPlayer);
  const nextIndex = currentIndex + 1;

  if (nextIndex < order.length) {
    document.getElementById(`pred-${order[nextIndex]}`).focus();
  } else {
    // ‚úÖ Focus Lock Predictions button only within the game section
    const lockBtn = document.querySelector("#game .btn-secondary[onclick='submitPredictions()']");
    if (lockBtn) lockBtn.focus();
  }
}

function focusNextActual(currentPlayer){
  const order=getPlayerOrderForRound();
  const currentIndex=order.indexOf(currentPlayer);
  const nextIndex=currentIndex+1;
  if(nextIndex<order.length){
    document.getElementById(`act-${order[nextIndex]}`).focus();
  } else {
    document.getElementById("submitBtn").focus();
  }
}

function updatePredictionSum(){
  let sum=0; players.forEach(p=>{ sum+=parseInt(document.getElementById(`pred-${p}`).value)||0; });
  document.getElementById("predSumDisplay").textContent=`Total Predictions: ${sum} / ${currentCards}`;
  return sum;
}

function submitPredictions(){
  let totalPred=0;
  const order=getPlayerOrderForRound();
  for(let p of order){
    const val=document.getElementById(`pred-${p}`).value.trim();
    if(val===""){alert(`Enter prediction for ${p}.`);return;}
    const num=parseInt(val);
    if(num>currentCards){alert(`${p} cannot predict more than ${currentCards} cards.`);return;}
    totalPred+=num;
  }
  if(totalPred===currentCards){alert("Total predictions cannot equal total cards in play.");return;}

  order.forEach(p=>{
    document.getElementById(`pred-${p}`).readOnly=true;
    document.getElementById(`act-${p}`).disabled=false;
  });

  // Auto focus first actual
  document.getElementById(`act-${order[0]}`).focus();
  highlightRow(order[0]);
  saveGameState();
  alert("Predictions locked! Play the round and fill actuals later.");
}

function calculateScore(pred,act){
  if(pred===0) return act===0?5:-5*act;
  if(pred===act) return pred*10;
  return (Math.abs(pred-act))*-10;
}

function submitRound() {
  const anyUnlocked = players.some(p => !document.getElementById(`pred-${p}`).readOnly);
  if (anyUnlocked) { alert("Lock predictions first!"); return; }

  let totalPred = 0, totalAct = 0;
  for (let p of players) {
    const pred = document.getElementById(`pred-${p}`).value;
    const act = document.getElementById(`act-${p}`).value;
    if (pred === "" || act === "") { alert("Fill all actuals."); return; }
    if (parseInt(pred) > currentCards) { alert(`${p} cannot predict more than ${currentCards}.`); return; }
  }

  players.forEach(p => {
    const pred = parseInt(document.getElementById(`pred-${p}`).value);
    const act = parseInt(document.getElementById(`act-${p}`).value);
    totalPred += pred; totalAct += act;
  });

  if (totalPred === currentCards) { alert("Predictions cannot equal cards."); return; }
  if (totalAct !== currentCards) { alert(`Actuals (${totalAct}) must equal cards in the round (${currentCards}).`); return; }

  players.forEach(p => {
    const pred = parseInt(document.getElementById(`pred-${p}`).value);
    const act = parseInt(document.getElementById(`act-${p}`).value);
    const sc = calculateScore(pred, act);
    scores[p] += sc;
    history.push({ round, cards: currentCards, player: p, prediction: pred, actual: act, score: sc, total: scores[p] });
  });

  renderScoreboard();
  renderHistory();
  saveGameState();

  // üèÅ If final round
  // üß≠ Move through sequence
  sequenceIndex++;

  if (sequenceIndex >= sequenceList.length) {
    // ‚úÖ Game Over
    document.getElementById("submitBtn").disabled = true;
    document.getElementById("roundInputs").innerHTML = "";
    document.getElementById("gameOver").textContent = "üéâ Game Over!";

    // üèÜ Determine all winners
    const maxScore = Math.max(...players.map(p => scores[p]));
    const topPlayers = players.filter(p => scores[p] === maxScore);

    const winnerCard = document.getElementById("winnerCard");
    winnerCard.innerHTML = `
      üèÜ <b>${topPlayers.join(" & ")}</b> ${topPlayers.length > 1 ? "Win!" : "Wins!"}
      <span>Score: ${maxScore}</span>
    `;
    winnerCard.style.display = "block";
    launchConfetti();
    return;
  }

  // Continue next round
  round++;
  currentCards = sequenceList[sequenceIndex];
  document.getElementById("roundNum").textContent = round;
  updateRoundColor();
  document.getElementById("cardsThisRound").value = currentCards;
  renderRoundInputs();
  updateProgress();
  players.forEach(p => document.getElementById(`pred-${p}`).readOnly = false);
  updatePredictionSum();
}


 



function renderScoreboard(){
  const tbody=document.querySelector("#scoreTable tbody"); tbody.innerHTML="";
  const sorted=[...players].sort((a,b)=>scores[b]-scores[a]);
  const maxScore=Math.max(...sorted.map(p=>scores[p]));
  const minScore=Math.min(...sorted.map(p=>scores[p]));
  sorted.forEach((p,i)=>{
    const tr=document.createElement("tr");
    const scClass=scores[p]>=0?"score-positive":"score-negative";
    if(scores[p]===maxScore)tr.classList.add("leader");
    if(scores[p]===minScore)tr.classList.add("loser");
    tr.innerHTML=`<td>${i+1}</td><td>${p}</td><td class="${scClass}">${scores[p]}</td>`;
    tbody.appendChild(tr);
  });
}

function renderHistory(filterPlayer="All"){
  const section=document.getElementById("historySection"); section.innerHTML="";
  const grouped={};
  history.forEach(r=>{
    if(filterPlayer!=="All"&&r.player!==filterPlayer)return;
    if(!grouped[r.round])grouped[r.round]=[];
    grouped[r.round].push(r);
  });
  for(let rnd in grouped){
    const rd=grouped[rnd];
    const colors=["#007bff","#28a745","#17a2b8","#6f42c1"];
    const c=colors[(rnd-1)%colors.length];
    const div=document.createElement("div"); div.className="round-card";
    div.innerHTML=`<h4 style="background:${c};">Round ${rnd} (${rd[0].cards} cards)</h4>
      <table><thead><tr><th>Player</th><th>Prediction</th><th>Actual</th><th>Score</th><th>Total</th></tr></thead>
      <tbody>${rd.map(r=>`<tr><td>${r.player}</td><td>${r.prediction}</td><td>${r.actual}</td><td>${r.score}</td><td>${r.total}</td></tr>`).join("")}</tbody></table>`;
    section.appendChild(div);
  }
}

function populateFilter(){
  const sel=document.getElementById("playerFilter");
  sel.innerHTML=`<option value="All">All</option>`+players.map(p=>`<option value="${p}">${p}</option>`).join("");
}

function undoLastRound(){
  if(history.length===0)return;
  const last=history[history.length-1].round;
  const removed=history.filter(h=>h.round===last);
  history=history.filter(h=>h.round!==last);
  removed.forEach(r=>scores[r.player]-=r.score);
  round--; currentCards++;
  document.getElementById("roundNum").textContent=round;
  updateRoundColor(); document.getElementById("cardsThisRound").value=currentCards;
  document.getElementById("submitBtn").disabled=false;
  document.getElementById("gameOver").textContent="";
  renderScoreboard(); renderHistory(); renderRoundInputs(); updateProgress(); saveGameState();
}

function updateProgress() {
  let totalRounds = sequenceList.length || maxCards;
  let done = sequenceIndex + 1;
  let percent = (done / totalRounds) * 100;
  document.getElementById("progressBar").style.width = percent + "%";
}

function toggleHistory(){
  const sec=document.getElementById("historySection");
  sec.style.display=sec.style.display==="none"?"block":"none";
}

function confirmNewGame(){
  const choice=confirm("Start new game?");
  if(!choice)return;
  const type=prompt("Type 'same' to play with same players or 'fresh' for fresh players:");
  if(type&&type.toLowerCase()==="fresh"){
    localStorage.removeItem("judgementPlayers");
    localStorage.removeItem("judgementGame");
    location.reload();
  } else {
    const stored=players.length?players:JSON.parse(localStorage.getItem("judgementPlayers"))||[];
    if(stored.length===0){location.reload();return;}
    localStorage.setItem("judgementPlayers",JSON.stringify(stored));
    localStorage.removeItem("judgementGame");
    maxCards=parseInt(prompt("Enter new max cards for next game:"))||5;
    startSamePlayersGame(stored);
  }
}

function startSamePlayersGame(stored){
sequenceType = localStorage.getItem("sequenceType") || "reverse";

// üîÅ rebuild the round sequence properly
if (sequenceType === "reverseForward") {
  sequenceList = [...Array(maxCards).keys()].map(i => maxCards - i)
    .concat([...Array(maxCards).keys()].map(i => i + 1));
} else {
  sequenceList = [...Array(maxCards).keys()].map(i => maxCards - i);
}

sequenceIndex = 0;
currentCards = sequenceList[sequenceIndex];

  players=[...stored]; scores={}; history=[]; round=1; currentCards=maxCards;
  players.forEach(p=>scores[p]=0);
  document.getElementById("setup").style.display="none";
  document.getElementById("game").style.display="block";
  document.getElementById("roundNum").textContent=round;
  updateRoundColor();
  document.getElementById("cardsThisRound").value=currentCards;
  renderRoundInputs();
  renderScoreboard();
  renderHistory();
  updateProgress();
  populateFilter();

  // ‚úÖ Fixes the bug and cleans visuals
  document.getElementById("submitBtn").disabled = false;
  document.getElementById("gameOver").textContent = "";
  document.getElementById("winnerCard").style.display = "none";
  document.getElementById("confettiContainer").innerHTML = "";
}


function saveGameState() {
  const roundPredictions = {};
  players.forEach(p => {
    const predInput = document.getElementById(`pred-${p}`);
    if (predInput) {
      roundPredictions[p] = {
        value: predInput.value,
        locked: predInput.readOnly // ‚úÖ always store, even if locked
      };
    }
  });

  const state = {
    players,
    scores,
    round,
    history,
    currentCards,
    maxCards,
    roundPredictions,
	sequenceIndex
  };

  localStorage.setItem("judgementGame", JSON.stringify(state));
  localStorage.setItem("judgementPlayers", JSON.stringify(players));
}

function launchConfetti() {
  const container = document.getElementById("confettiContainer");
  container.innerHTML = ""; // clear old confetti
  const colors = ["#FFD700", "#FF4500", "#00FA9A", "#1E90FF", "#FF69B4"];

  for (let i = 0; i < 80; i++) {
    const conf = document.createElement("div");
    conf.style.position = "absolute";
    conf.style.width = `${Math.random() * 8 + 4}px`;
    conf.style.height = `${Math.random() * 8 + 4}px`;
    conf.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
    conf.style.left = Math.random() * 100 + "vw";
    conf.style.top = "-10px";
    conf.style.opacity = Math.random();
    conf.style.transform = `rotate(${Math.random() * 360}deg)`;
    conf.style.borderRadius = "50%";
    container.appendChild(conf);

    // Animate fall
    const fall = conf.animate([
      { transform: `translateY(0) rotate(0deg)` },
      { transform: `translateY(${window.innerHeight}px) rotate(${Math.random() * 360}deg)` }
    ], {
      duration: 3000 + Math.random() * 2000,
      easing: "ease-out",
      iterations: 1,
      fill: "forwards"
    });

    // Remove when done
    fall.onfinish = () => conf.remove();
  }
}



function loadGameState() {
  const saved = JSON.parse(localStorage.getItem("judgementGame") || "null");
  sequenceType = localStorage.getItem("sequenceType") || "reverse";
maxCards = saved.maxCards || parseInt(localStorage.getItem("maxCards")) || 0;

// Rebuild sequence list after refresh
if (sequenceType === "reverseForward") {
  sequenceList = [...Array(maxCards).keys()].map(i => maxCards - i)
    .concat([...Array(maxCards).keys()].map(i => i + 1));
} else {
  sequenceList = [...Array(maxCards).keys()].map(i => maxCards - i);
}

// Determine where we left off
sequenceIndex = saved.sequenceIndex || history.length > 0
  ? history[history.length - 1].round
  : 0;

currentCards = sequenceList[sequenceIndex] || sequenceList[0];

  if (!saved) return;

  ({ players, scores, round, history, currentCards, maxCards } = saved);

  const roundCompleted = history.some(h => h.round === round);
  if (roundCompleted) {
    round++;
    currentCards = maxCards - (round - 1);
    saved.roundPredictions = {}; // clear stale data for new round
  }

  if (players.length > 0) {
    document.getElementById("setup").style.display = "none";
    document.getElementById("game").style.display = "block";
    document.getElementById("roundNum").textContent = round;
    updateRoundColor();
    document.getElementById("cardsThisRound").value = currentCards;

    renderRoundInputs();

    // ‚úÖ Restore predictions after rendering table
    if (saved.roundPredictions && Object.keys(saved.roundPredictions).length > 0) {
      players.forEach(p => {
        const predData = saved.roundPredictions[p];
        if (predData && predData.value !== undefined) {
          const predInput = document.getElementById(`pred-${p}`);
          const actInput = document.getElementById(`act-${p}`);

          if (predInput) {
            predInput.value = predData.value;
            predInput.readOnly = false; // üîì make editable again after refresh
          }
          if (actInput) actInput.disabled = true; // keep actuals disabled until lock
        }
      });
      updatePredictionSum();
    }

    renderScoreboard();
    renderHistory();
    updateProgress();
    populateFilter();
  }
}


function exportHistory(){
  if(history.length===0){alert("No history yet!");return;}
  let csv="Round,Cards,Player,Prediction,Actual,Score,Total\n";
  history.forEach(r=>csv+=`${r.round},${r.cards},${r.player},${r.prediction},${r.actual},${r.score},${r.total}\n`);
  const blob=new Blob([csv],{type:"text/csv"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download="judgement_history.csv"; a.click();
}
function exportPDF(){ window.print(); }

document.getElementById("maxCardsInput").addEventListener("input", e => {
  document.getElementById("sequenceTypeContainer").style.display = e.target.value ? "block" : "none";
});

loadGameState();

</script>
</body>
</html>
